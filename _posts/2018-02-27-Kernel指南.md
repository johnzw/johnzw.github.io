---
layout: post
title: "OS Kernel Guide"
description: ""
category: 
tags: [OS]
---
{% include JB/setup %}
### OS出现的意义
先温习一下，程序到底都是在干什么。简而言之，CPU从内存上取指令执行指令，CPU从内存上取数据或者把数据放到内存上，CPU从外部设备(I/O device)上取数据放数据。

上古时期，一段程序在一个机子上运行，心安理得地使用着所有的资源（内存、CPU和各种输入输出硬件），当然前提是这小程序也得对这台机子所有资源有着了解。

但后来，随着各家厂商纷纷贡献者自己的一份力，各自造不一样的硬件，小程序开始hold不住了，但也活该它，是它想要的太多，想要匹配所有厂家。但同时，更重要的需求出现了，我们需要计算机同时解决不一样的任务了。而一段小程序如果里面加上各种不太相关的执行逻辑，程序员们可能要爆炸了。这个时候，更说的通的设计是，写好几个解决不同任务的程序。

##### OS的出现，解决了谁的问题，解决了什么问题？

OS为develper(user program developer)解决了困扰。他们不需要去考虑真正的内存(RAM)限制，不需要多想硬件设备(硬件输入输出)，也不需要去想更复杂的问题比如，多个程序如何“同时”地在一个计算机里面运行：多个程序的地址空间(address space)如何共存，多个程序如何看起来“同时”使用CPU。

OS为develper提供了
- 进程线程的概念。程序员以为自己写的程序以进程为单位在计算机中被执行，以线程为单位，执行着所有指令，“霸占”着“所有”CPU （Kernel1实现这样的抽象）
- 专属的地址空间。程序员以为自己写的程序“霸占”着一片地址空间（32bit中是4G），并且从内存地址上拿指令或者拿数据或者放数据，就像这内存是自家的一样（Kernel3实现这样的抽象）
- 文件的概念。程序员以为文件就是所谓的输入输出设备，他们会往这文件里面放数据以及取数据（Kernel2实现这样的抽象）



## kernel1

Spec和FAQ的帮助很大，强烈建议事先读一遍（相应章节），如果还是不知道怎么下手，希望下面的能帮到你。

先说一下我最开始的困惑吧。

##### 这个kernel程序，也是像普通user program一样运行么？
嗯，就像一个普通的C程序一样。
##### 看到FAQ说kernel1不涉及user process，那我在里面创造了一个kernel process是什么意思，是个独立的程序么？
这个大kernel程序就像一个大房子，一个巨大的进程。我在里面创造了一个又一个所有的kernel process（idle process, init process，还有faber_test中创造各种进程）。但这一切就像过家家一样，这些进程并不是创造到家外面去了，而是还待在这个房子里面。只不过这些进程都有相应执行的线程，而线程要执行什么东西呢，是和它绑定的function。
##### 那把这些进程创造出来有什么意义呢？
创造出来了之后，你之后执行的视角就改变了。
原本你站在房子顶上，俯视大地，创造进程，连接function和线程，连接线程和进程。但是当在`bootstrap()`中，`context_make_active()`后，你的执行视角就改变了，以进程的身份，线程的姿态，去执行一行行code。并在该被context switch的时候，主动要求进入队列，执行的context被换成其他线程了；或者死掉了。
这就是Bill Cheng所说的，从bootstrap中进入process context


#### kernel实现感受

我认为kernel和我们以往写的程序比较不一样的地方在于（可能会让我们一开始不知道怎么下手），一方面我们自己提供并且实现着某种抽象，但同时我们又使用着这种抽象。


## Kernel2
To be continued...
## Kernel3
To be continued...